#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>



int main() {
    int _O_TEXT;  // Объявление переменной _O_TEXT для использования в функции _pipe
    int fd[2];  // Объявление массива файловых дескрипторов, где fd[0] для чтения, а fd[1] для записи
    ssize_t size;  // Изменено на ssize_t для хранения результатов вызовов read/write
    char string[] = "Hello, world!";  // Инициализация строки "Hello, world!"
    char resstring[14];  // Массив размера 14 для хранения строки "Hello, world!"

    if(_pipe(fd, 4096, _O_TEXT) < 0){  // Создание пайпа с буфером 4096 байт и режимом _O_TEXT
        printf("Can't create pipe\n");  // Вывод сообщения об ошибке при неудачном создании пайпа
        exit(-1);  // Завершение программы с кодом ошибки -1
    }

    size = _write(fd[1], string, sizeof(string));  // Запись строки в пайп
    if(size != sizeof(string)){  // Проверка, что записано правильное количество байт
        printf("Can't write all string\n");  // Вывод сообщения об ошибке при неудачной записи
        exit(-1);  // Завершение программы с кодом ошибки -1
    }

    size = _read(fd[0], resstring, sizeof(resstring) - 1);  // Чтение строки из пайпа, учитываем нулевой символ
    if(size < 0){  // Проверка на ошибки при чтении
        printf("Can't read string\n");  // Вывод сообщения об ошибке при неудачном чтении
        exit(-1);  // Завершение программы с кодом ошибки -1
    }
    resstring[size] = '\0';  // Добавление нулевого символа в конец строки для корректного отображения

    printf("%s\n", resstring);  // Вывод строки

    if(close(fd[0]) < 0){  // Закрытие пайпа для чтения
        printf("Can't close input stream\n");  // Вывод сообщения об ошибке при неудачном закрытии
    }

    if(close(fd[1]) < 0){  // Закрытие пайпа для записи
        printf("Can't close output stream\n");  // Вывод сообщения об ошибке при неудачном закрытии
    }

    return 0;  // Завершение программы с кодом 0 (успешное завершение)
}
